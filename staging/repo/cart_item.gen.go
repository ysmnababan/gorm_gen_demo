// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package repo

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gorm_demo/staging/model"
)

func newCartItem(db *gorm.DB, opts ...gen.DOOption) cartItem {
	_cartItem := cartItem{}

	_cartItem.cartItemDo.UseDB(db, opts...)
	_cartItem.cartItemDo.UseModel(&model.CartItem{})

	tableName := _cartItem.cartItemDo.TableName()
	_cartItem.ALL = field.NewAsterisk(tableName)
	_cartItem.CreatedAt = field.NewInt64(tableName, "created_at")
	_cartItem.CreatedBy = field.NewString(tableName, "created_by")
	_cartItem.ModifiedAt = field.NewInt64(tableName, "modified_at")
	_cartItem.ModifiedBy = field.NewString(tableName, "modified_by")
	_cartItem.DeletedAt = field.NewInt64(tableName, "deleted_at")
	_cartItem.DeletedBy = field.NewString(tableName, "deleted_by")
	_cartItem.CartItemID = field.NewString(tableName, "cart_item_id")
	_cartItem.CartID = field.NewInt64(tableName, "cart_id")
	_cartItem.OutletMenuID = field.NewString(tableName, "outlet_menu_id")
	_cartItem.Qty = field.NewInt32(tableName, "qty")
	_cartItem.Notes = field.NewString(tableName, "notes")

	_cartItem.fillFieldMap()

	return _cartItem
}

type cartItem struct {
	cartItemDo

	ALL          field.Asterisk
	CreatedAt    field.Int64
	CreatedBy    field.String
	ModifiedAt   field.Int64
	ModifiedBy   field.String
	DeletedAt    field.Int64
	DeletedBy    field.String
	CartItemID   field.String
	CartID       field.Int64
	OutletMenuID field.String
	Qty          field.Int32
	Notes        field.String

	fieldMap map[string]field.Expr
}

func (c cartItem) Table(newTableName string) *cartItem {
	c.cartItemDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c cartItem) As(alias string) *cartItem {
	c.cartItemDo.DO = *(c.cartItemDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *cartItem) updateTableName(table string) *cartItem {
	c.ALL = field.NewAsterisk(table)
	c.CreatedAt = field.NewInt64(table, "created_at")
	c.CreatedBy = field.NewString(table, "created_by")
	c.ModifiedAt = field.NewInt64(table, "modified_at")
	c.ModifiedBy = field.NewString(table, "modified_by")
	c.DeletedAt = field.NewInt64(table, "deleted_at")
	c.DeletedBy = field.NewString(table, "deleted_by")
	c.CartItemID = field.NewString(table, "cart_item_id")
	c.CartID = field.NewInt64(table, "cart_id")
	c.OutletMenuID = field.NewString(table, "outlet_menu_id")
	c.Qty = field.NewInt32(table, "qty")
	c.Notes = field.NewString(table, "notes")

	c.fillFieldMap()

	return c
}

func (c *cartItem) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *cartItem) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 11)
	c.fieldMap["created_at"] = c.CreatedAt
	c.fieldMap["created_by"] = c.CreatedBy
	c.fieldMap["modified_at"] = c.ModifiedAt
	c.fieldMap["modified_by"] = c.ModifiedBy
	c.fieldMap["deleted_at"] = c.DeletedAt
	c.fieldMap["deleted_by"] = c.DeletedBy
	c.fieldMap["cart_item_id"] = c.CartItemID
	c.fieldMap["cart_id"] = c.CartID
	c.fieldMap["outlet_menu_id"] = c.OutletMenuID
	c.fieldMap["qty"] = c.Qty
	c.fieldMap["notes"] = c.Notes
}

func (c cartItem) clone(db *gorm.DB) cartItem {
	c.cartItemDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c cartItem) replaceDB(db *gorm.DB) cartItem {
	c.cartItemDo.ReplaceDB(db)
	return c
}

type cartItemDo struct{ gen.DO }

type ICartItemDo interface {
	gen.SubQuery
	Debug() ICartItemDo
	WithContext(ctx context.Context) ICartItemDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ICartItemDo
	WriteDB() ICartItemDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ICartItemDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ICartItemDo
	Not(conds ...gen.Condition) ICartItemDo
	Or(conds ...gen.Condition) ICartItemDo
	Select(conds ...field.Expr) ICartItemDo
	Where(conds ...gen.Condition) ICartItemDo
	Order(conds ...field.Expr) ICartItemDo
	Distinct(cols ...field.Expr) ICartItemDo
	Omit(cols ...field.Expr) ICartItemDo
	Join(table schema.Tabler, on ...field.Expr) ICartItemDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ICartItemDo
	RightJoin(table schema.Tabler, on ...field.Expr) ICartItemDo
	Group(cols ...field.Expr) ICartItemDo
	Having(conds ...gen.Condition) ICartItemDo
	Limit(limit int) ICartItemDo
	Offset(offset int) ICartItemDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ICartItemDo
	Unscoped() ICartItemDo
	Create(values ...*model.CartItem) error
	CreateInBatches(values []*model.CartItem, batchSize int) error
	Save(values ...*model.CartItem) error
	First() (*model.CartItem, error)
	Take() (*model.CartItem, error)
	Last() (*model.CartItem, error)
	Find() ([]*model.CartItem, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CartItem, err error)
	FindInBatches(result *[]*model.CartItem, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.CartItem) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ICartItemDo
	Assign(attrs ...field.AssignExpr) ICartItemDo
	Joins(fields ...field.RelationField) ICartItemDo
	Preload(fields ...field.RelationField) ICartItemDo
	FirstOrInit() (*model.CartItem, error)
	FirstOrCreate() (*model.CartItem, error)
	FindByPage(offset int, limit int) (result []*model.CartItem, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ICartItemDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c cartItemDo) Debug() ICartItemDo {
	return c.withDO(c.DO.Debug())
}

func (c cartItemDo) WithContext(ctx context.Context) ICartItemDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c cartItemDo) ReadDB() ICartItemDo {
	return c.Clauses(dbresolver.Read)
}

func (c cartItemDo) WriteDB() ICartItemDo {
	return c.Clauses(dbresolver.Write)
}

func (c cartItemDo) Session(config *gorm.Session) ICartItemDo {
	return c.withDO(c.DO.Session(config))
}

func (c cartItemDo) Clauses(conds ...clause.Expression) ICartItemDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c cartItemDo) Returning(value interface{}, columns ...string) ICartItemDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c cartItemDo) Not(conds ...gen.Condition) ICartItemDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c cartItemDo) Or(conds ...gen.Condition) ICartItemDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c cartItemDo) Select(conds ...field.Expr) ICartItemDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c cartItemDo) Where(conds ...gen.Condition) ICartItemDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c cartItemDo) Order(conds ...field.Expr) ICartItemDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c cartItemDo) Distinct(cols ...field.Expr) ICartItemDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c cartItemDo) Omit(cols ...field.Expr) ICartItemDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c cartItemDo) Join(table schema.Tabler, on ...field.Expr) ICartItemDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c cartItemDo) LeftJoin(table schema.Tabler, on ...field.Expr) ICartItemDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c cartItemDo) RightJoin(table schema.Tabler, on ...field.Expr) ICartItemDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c cartItemDo) Group(cols ...field.Expr) ICartItemDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c cartItemDo) Having(conds ...gen.Condition) ICartItemDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c cartItemDo) Limit(limit int) ICartItemDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c cartItemDo) Offset(offset int) ICartItemDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c cartItemDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ICartItemDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c cartItemDo) Unscoped() ICartItemDo {
	return c.withDO(c.DO.Unscoped())
}

func (c cartItemDo) Create(values ...*model.CartItem) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c cartItemDo) CreateInBatches(values []*model.CartItem, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c cartItemDo) Save(values ...*model.CartItem) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c cartItemDo) First() (*model.CartItem, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.CartItem), nil
	}
}

func (c cartItemDo) Take() (*model.CartItem, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.CartItem), nil
	}
}

func (c cartItemDo) Last() (*model.CartItem, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.CartItem), nil
	}
}

func (c cartItemDo) Find() ([]*model.CartItem, error) {
	result, err := c.DO.Find()
	return result.([]*model.CartItem), err
}

func (c cartItemDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CartItem, err error) {
	buf := make([]*model.CartItem, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c cartItemDo) FindInBatches(result *[]*model.CartItem, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c cartItemDo) Attrs(attrs ...field.AssignExpr) ICartItemDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c cartItemDo) Assign(attrs ...field.AssignExpr) ICartItemDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c cartItemDo) Joins(fields ...field.RelationField) ICartItemDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c cartItemDo) Preload(fields ...field.RelationField) ICartItemDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c cartItemDo) FirstOrInit() (*model.CartItem, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.CartItem), nil
	}
}

func (c cartItemDo) FirstOrCreate() (*model.CartItem, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.CartItem), nil
	}
}

func (c cartItemDo) FindByPage(offset int, limit int) (result []*model.CartItem, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c cartItemDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c cartItemDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c cartItemDo) Delete(models ...*model.CartItem) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *cartItemDo) withDO(do gen.Dao) *cartItemDo {
	c.DO = *do.(*gen.DO)
	return c
}
